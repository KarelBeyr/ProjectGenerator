using System.Text;
using System.Xml.Linq;

namespace ProjectGenerator;

public class ServicesGenerator : GeneratorBase
{
    //generates services

    public void Generate(DataModel dataModel)
    {
        foreach (var cls in dataModel.Classes.Values.Where(e => e.IsModel))
        {
            var serviceName = $"{cls.Name}Service";
            var repositoryName = $"_{Utils.LowerCaseFirst(cls.Name)}Repository";
            var pkField = cls.PrimaryKeyField();
            var pkFieldVarName = Utils.LowerCaseFirst(pkField.Name);
            var sb = new IndentingStringBuilder();

            sb.AppendLine($"using {GeneratedProjectNamespace}.Infrastructure;");
            sb.AppendLine($"using {GeneratedProjectNamespace}.Repositories;");
            sb.AppendLine($"using {GeneratedProjectNamespace}.Commands;");
            sb.AppendLine($"using {GeneratedProjectNamespace}.Interfaces;");
            sb.AppendLine($"using {GeneratedProjectNamespace}.Entities;");
            sb.AppendLine($"using {GeneratedProjectNamespace}.Models;");
            sb.AppendLine($"using IOTA.Core.Security;");
            

            sb.AppendLine($"namespace {GeneratedProjectNamespace}.Services;");
            sb.AppendLine();

            sb.AppendLine($"public class {serviceName}: I{serviceName}");
            sb.IncreaseIndent();
            sb.AppendLine($"private readonly I{cls.Name}Repository {repositoryName};");
            sb.AppendLine($"private readonly IUnitOfWork _unitOfWork;");
            sb.AppendLine($"private readonly IUsers _users;");
            sb.AppendLine($"");
            sb.AppendLine($"public {serviceName}(I{cls.Name}Repository {repositoryName.Substring(1)}, IUnitOfWork unitOfWork, IUsers users)");
            sb.IncreaseIndent();
            sb.AppendLine($"{repositoryName} = {repositoryName.Substring(1)};");
            sb.AppendLine($"_unitOfWork = unitOfWork;");
            sb.AppendLine($"_users = users;");
            sb.DecreaseIndent();
            sb.AppendLine($"");

            ///////////////GET
            sb.AppendLine($"async Task<{cls.Name}Model> I{serviceName}.Get({pkField.TypeName} {pkFieldVarName})");
            sb.IncreaseIndent();
            sb.AppendLine($"var entity = await {repositoryName}.Get({pkFieldVarName});");
            sb.AppendLine($"if (entity == null) throw new NotFoundException(\"{cls.Name} with given name not found\");");
            sb.AppendLine($"var model = new {cls.Name}Model");
            sb.IncreaseIndent();
            foreach (var field in cls.Fields.Where(e => !e.IsPrimaryKey && !e.IsOnlyInDb))
            {
                sb.AppendLine($"{field.Name} = entity.{field.Name},");
            }
            sb.DecreaseIndent(";");
            sb.AppendLine($"return model;");
            sb.DecreaseIndent();
            sb.AppendLine();

            ///////////////CREATE
            /*
            async Task<bool> IUserSettingDefaultsService.Create(CreateUserSettingDefaultCommand command)
            {
                EnsurePermissionAndAccess("SecNG_UserSettingDefaults_CRUD", command.Authorization);

                //TODO_Dejan: In IOTP-725 Iva mentions endpoint for Create/Update. I don't know if it means two endpoints, or just one. I leave it up to you to decide (but I personally would prefer to have two endpoins. Create endpoint should check for existing value and fail if it already exists. Update, on the other hand, should fail if it does not exist)
                var found = await _userSettingDefaultsRepository.GetUserSettingDefaultByName(command.Name);
                if (found != null) throw new InvalidStateException("User setting default with given name already exists");

                var entity = new UserSettingDefault
                {
                    Name = command.Name,
                    Value = command.Value
                };

                _userSettingDefaultsRepository.Save(entity);
                await _unitOfWork.SaveChanges();
                return true;
            }
            */
            sb.AppendLine($"async Task<{pkField.TypeName}> I{serviceName}.Create(Create{cls.Name}Command command)");
            sb.IncreaseIndent();
            sb.AppendLine("//TODO EnsurePermissionAndAccess(...) ");
            if (!pkField.IsAutogeneratedKey)
            {
                sb.AppendLine($"var found = await {repositoryName}.Get(command.{pkField.Name});");
                sb.AppendLine($"if (found != null) throw new InvalidStateException(\"{cls.Name} with given {pkField.Name} already exists\");");
            }
            sb.AppendLine($"var entity = new {cls.Name}");
            sb.IncreaseIndent();
            foreach (var field in cls.Fields.Where(e => (!e.IsPrimaryKey || !e.IsAutogeneratedKey) && !e.IsOnlyInDb))
            {
                sb.AppendLine($"{field.Name} = command.{field.Name},");
            }
            sb.DecreaseIndent(";");
            sb.AppendLine($"{repositoryName}.Save(entity);");
            sb.AppendLine($"_unitOfWork.SaveChanges();");
            sb.AppendLine($"return entity.{pkField.Name};");
            sb.DecreaseIndent();



            sb.DecreaseIndent();
File.WriteAllText($"{BasePath}Services.{cls.Name}.g.cs", sb.ToString());
}
}

public override bool ShouldGenerateField(Field field, string action)
{
if (field.IsOnlyInDb) return false;
if (field.IsOnlyCreate && action == "updateModel") return false;
if (field.IsPrimaryKey && action == "createModel") return false;
if (field.IsPrimaryKey && action == "updateModel") return false;
return true;
}
}
